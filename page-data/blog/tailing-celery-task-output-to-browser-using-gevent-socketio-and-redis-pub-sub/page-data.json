{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-js","path":"/blog/tailing-celery-task-output-to-browser-using-gevent-socketio-and-redis-pub-sub/","result":{"data":{"markdownRemark":{"html":"<p>While working on a project at work I wanted to add a feature that displayed the output of a long running task in the browser in near real-time. This features was inspired by <a href=\"http://travis-ci.org/\">travis-ci.org</a>. If you're unfamiliar with Travis, the browser client displays the build log output as it is happening. After some tooling around and asking some random questions on IRC I was able to determine that this could be done using Socket.IO and the Redis Pub/Sub features.</p>\n<h2>Overview</h2>\n<p>Socket.IO is a websocket application framework that was originally written in JavaScript for the Node.js platform. In my case I wanted to avoid adding another stack into our infrastructure and luckily there exists <a href=\"https://gevent-socketio.readthedocs.org/\">gevent-socketio</a>, a Python implementation of the Socket.IO server. In this implementation Socket.IO will be used to push messages to the browser that are \"dispatched\" via Redis's <a href=\"http://redis.io/topics/pubsub\">Pub/Sub implementation</a>. This tutorial will describe a very basic application that fulfills the functionality that I happened to be looking for. It assumes you have a working knowledge of Python, Flask, Celery, Redis and JavaScript. The source files for this application can be found over at my GitHub account: <a href=\"https://github.com/mattupstate/gevent-socketio-tutorial\">https://github.com/mattupstate/gevent-socketio-tutorial</a>.</p>\n<h2>Components</h2>\n<p>There are five components to this application. They are:</p>\n<ul>\n<li>Frontend Application <strong>(JavaScript/Socket.IO)</strong></li>\n<li>Backend Application <strong>(Python/Flask)</strong></li>\n<li>Asynchronous Application <strong>(Python/Celery)</strong></li>\n<li>Socket Server <strong>(Python/gevent-socketio)</strong></li>\n<li>Message Broker <strong>(Redis)</strong></li>\n</ul>\n<h3>Frontend Application</h3>\n<p>The frontend application, most importantly, uses the Socket.IO client side library for managing the connection and receiving messages from the socket server. The source code for this application can be found in <code class=\"language-text\">app/templates/index.html</code>. The important bit of JavaScript is located near the bottom of this file:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> socket <span class=\"token operator\">=</span> io<span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"http://localhost:5000/tail\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsocket<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"subscribe\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsocket<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tail-message\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">$</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".log-output\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>In the previous snippet a connection object is configured with a connection to the <code class=\"language-text\">tail</code> namespace. This is followed by sending a <code class=\"language-text\">subscribe</code> message to the server. This notifies the server that this particular client should receive messages from the <code class=\"language-text\">tail</code> namespace. Namespaces are a feature of Socket.IO that allow a developer to group messages. More on this later. Lastly, the client defines a handler function to receive <code class=\"language-text\">tail-message</code> messages. These messages are then appended as text to a DOM element.</p>\n<h3>Backend Application</h3>\n<p>The backend application is where requests to start the long running task are initiated. In the case of this tutorial only one task can be running at any given time for the sake of simplicity. The important source code regarding this functionality is located in <code class=\"language-text\">app/__init__.py</code>. One Flask endpoint defined and handles the aforementioned functionality:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token decorator annotation punctuation\">@app<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">,</span> methods<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'POST'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">index</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> request<span class=\"token punctuation\">.</span>method <span class=\"token operator\">==</span> <span class=\"token string\">'POST'</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> redis<span class=\"token punctuation\">.</span>llen<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span>MESSAGES_KEY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            flash<span class=\"token punctuation\">(</span><span class=\"token string\">'Task is already running'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'error'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            tail<span class=\"token punctuation\">.</span>delay<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            flash<span class=\"token punctuation\">(</span><span class=\"token string\">'Task started'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'info'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> render_template<span class=\"token punctuation\">(</span><span class=\"token string\">'index.html'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>In this endpoint the application determines if the user has requested to start the long running task. This happens when an HTTP POST request is sent. When the task is running there will be data in the form of a list stored in Redis under the key specified by the application's <code class=\"language-text\">MESSAGES_KEY</code> configuration value. If data does not exist for this key the task is then started by calling <code class=\"language-text\">tail.delay()</code>. The <code class=\"language-text\">tail</code> function is a Celery task that will be explained in a moment.</p>\n<h3>Asynchronous Application</h3>\n<p>The asynchronous application performs the long running task. The source code for this part of the application is also located in <code class=\"language-text\">app/__init__.py</code>. The important code is as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token decorator annotation punctuation\">@celery<span class=\"token punctuation\">.</span>task</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">tail</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        msg <span class=\"token operator\">=</span> <span class=\"token string\">'Task message %s\\n'</span> <span class=\"token operator\">%</span> i\n        redis<span class=\"token punctuation\">.</span>rpush<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span>MESSAGES_KEY<span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">)</span>\n        redis<span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span>CHANNEL_NAME<span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">)</span>\n        time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    redis<span class=\"token punctuation\">.</span>delete<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span>MESSAGES_KEY<span class=\"token punctuation\">)</span></code></pre></div>\n<p>In the case of this application the task is simply a function that runs for approximately 20 seconds. During these 20 seconds a message is appended to the list stored in Redis and also published to a channel specified by the applications <code class=\"language-text\">CHANNEL_NAME</code> configuration value. The reason that the message is both stored and published is to have be able to return all the back messages if the browser happens to be refreshed or a client connects while the task is running but after it has started. When the task is complete the list value in Redis is deleted so that the application can determine if the task is running or not.</p>\n<h3>Socket Server</h3>\n<p>The socket server acts as a layer between Redis and the frontend application. It is here that messages published to Redis are received and then dispatched or <code class=\"language-text\">emitted</code> to the front end application. This source code is also located in <code class=\"language-text\">app/__init__.py</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token decorator annotation punctuation\">@app<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/socket.io/&lt;path:remaining>'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">socketio</span><span class=\"token punctuation\">(</span>remaining<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    socketio_manage<span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span>environ<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">'/tail'</span><span class=\"token punctuation\">:</span> TailNamespace\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> app<span class=\"token punctuation\">.</span>response_class<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The previous snippet attaches the Socket.IO <code class=\"language-text\">tail</code> namespace to the Flask application via the <code class=\"language-text\">socketio.socketio_manage</code> method. This method is passed the request context from Flask and a dictionary containing the various namespaces that should be available.</p>\n<p>This endpoint is rather handy as it allows the gevent-socketio server and Flask application the be combined as one WSGI application. Thus it can be run under the same process on your webserver. One less thing to manage! Additionally, the <code class=\"language-text\">tail</code> namespace is defined as the <code class=\"language-text\">TailNamespace</code> class:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">TailNamespace</span><span class=\"token punctuation\">(</span>BaseNamespace<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">listener</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># Emit the backlog of messages</span>\n        messages <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span>lrange<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span>MESSAGES_KEY<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>emit<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span>SOCKETIO_CHANNEL<span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span>messages<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n        pubsub<span class=\"token punctuation\">.</span>subscribe<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span>CHANNEL_NAME<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">for</span> m <span class=\"token keyword\">in</span> pubsub<span class=\"token punctuation\">.</span>listen<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> m<span class=\"token punctuation\">[</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">:</span>\n                self<span class=\"token punctuation\">.</span>emit<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span>SOCKETIO_CHANNEL<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">[</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">on_subscribe</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>spawn<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>listener<span class=\"token punctuation\">)</span></code></pre></div>\n<p>This class extends the <code class=\"language-text\">socketio.namespace.BaseNamespace</code> class and must implement the <code class=\"language-text\">on_subscribe</code> method. In this case, when a client subscribes to the tail namespace (see the frontend app) the <code class=\"language-text\">listener</code> method is \"spawned\". Meaning it is called once for the client that happens to subscribe to the <code class=\"language-text\">tail</code> namespace. In this case the <code class=\"language-text\">listener</code> method simply subscribes to the same channel that the Celery task publishes to and as messages are received they are \"emitted\" to the client. However, this does not happen until a list of all the previous messages are retrieved and emitted in order for the client to receive the backlog if they connect after the task has started.</p>\n<h3>Message Broker</h3>\n<p>The message broker for this application is a running instance of Redis. The application is configured to connect to a running instance of Redis at <code class=\"language-text\">192.168.0.10</code>. If you have an instance of Redis running already change this value in the <code class=\"language-text\">app.config.py</code> file. If you happen to a Vagrant user, the supplied <code class=\"language-text\">Vagrantfile</code> will spin up a VM for you and you should not have to change this configuration value.</p>\n<h2>Wrap Up</h2>\n<p>Now that you have an understanding of the various components for this application you can see it in action by running the Flask/Socket.IO server and the Celery application. Each will need to run as separate processes. You can do this by opening two separate terminal sessions and running the following commands:</p>\n<p>Flask/Socket.IO server:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ python server.py</code></pre></div>\n<p>Celery workers:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ celery <span class=\"token parameter variable\">-A</span> <span class=\"token string\">'app.celery'</span> worker</code></pre></div>\n<p>Now open your browser and go to <a href=\"http://localhost:5000/\">http://localhost:5000</a>. Click the button labeled <strong>Start Task</strong> and marvel in how the task output is pushed to the browser in near real time! Refresh the browser while the task is running to see that one can connect at any time to see the past and current task output.</p>\n<h2>Next Steps</h2>\n<p>Imagine now that you can publish messages to unique channel names for long running processes that may be happening at the same time. For instance, in my application my Celery tasks create custom AMI's for EC2 that are bootstrapped via Chef. The frontend application lets me configure a server with various roles and other properties and an entry in the database is created. The build task then uses the unique ID as a suffix and publishes to a unique channel. The frontend application sends the unique ID along with the \"subscribe\" message:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">socket<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'subscribe'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'&lt;the build id>'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>And the <code class=\"language-text\">on_subscribe</code> method of the namespace class accepts one parameter:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">on_subscribe</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> build_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    self<span class=\"token punctuation\">.</span>spawn<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>listener<span class=\"token punctuation\">,</span> build_id<span class=\"token punctuation\">)</span></code></pre></div>\n<p>The ID can then be used to within the <code class=\"language-text\">listener</code> function to publish to the unique channel name.</p>","frontmatter":{"date":"February 13, 2013","slug":"/blog/tailing-celery-task-output-to-browser-using-gevent-socketio-and-redis-pub-sub","title":"Tailing Celery Task Output to a Browser Using gevent-socketio and Redis Pub/Sub","description":null}},"metaImageFile":{"relativePath":"images/headshot-summary.png","childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#583828","images":{"fallback":{"src":"/static/9798db320c5cad183af92ab85933ac64/38397/headshot-summary.png","srcSet":"/static/9798db320c5cad183af92ab85933ac64/cef30/headshot-summary.png 531w,\n/static/9798db320c5cad183af92ab85933ac64/d6f8b/headshot-summary.png 1061w,\n/static/9798db320c5cad183af92ab85933ac64/38397/headshot-summary.png 2122w","sizes":"(min-width: 2122px) 2122px, 100vw"},"sources":[{"srcSet":"/static/9798db320c5cad183af92ab85933ac64/45ee3/headshot-summary.webp 531w,\n/static/9798db320c5cad183af92ab85933ac64/af37a/headshot-summary.webp 1061w,\n/static/9798db320c5cad183af92ab85933ac64/c2899/headshot-summary.webp 2122w","type":"image/webp","sizes":"(min-width: 2122px) 2122px, 100vw"}]},"width":2122,"height":1070}}}},"pageContext":{"id":"718ba50c-e8e7-5ff9-8b86-e5dff71a60bd","frontmatter__slug":"/blog/tailing-celery-task-output-to-browser-using-gevent-socketio-and-redis-pub-sub","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["2052298874"]}